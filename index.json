[{"content":"Introducción Python es un lenguaje de programación fácil de aprender, con estructuras de datos eficientes. Es considerado como el lenguaje más popular para aprender por su versatilidad, su enfoque sencillo y la cantidad de librerías disponibles para machine learning, análisis de datos y visualización de datos.\nSalida por pantalla Lo primero que se suele hacer cuando aprendemos a programar es saludar. Hello world.\nprint(\"Hello world\") print(1+1) Un comentario Los comentarios son porciones del código que no se ejecutan. Son eso, comentarios.\n# Hola, soy un comentario. print(\"Hello world\") print(1+1) # Hola, soy un comentario. # print(\"Hello world\") # Acabo de comentar esta linea print(1+1) Variables Una variable es una ubicación en memoria que tiene un nombre simbólico asociado y que puede guardar información.\nDeclarar una variable es tan fácil como definir un nombre y dar un valor.\na = 2 print(a) Tipo de datos Python es un lenguaje de tipado dinámico. Es decir, no tenemos que definir el tipo de dato. Python asumirá el tipo de valor usando una regla llamada duck typing:\n“Si veo un ave que camina como un pato, nada como un pato y suena como un pato, entonces a esa ave yo la llamo un pato.”\nEnteros (int) a = 1 print(a) print(type(a)) Flotantes (float) a = 3.98 print(a) print(type(a)) a = 1.0 print(a) print(type(a)) Booleanos (bool) a = True print(a) print(type(a)) a = 1 print(a) print(type(a)) Cadenas de texto (str) a = \"Hola\" print(a) Convertir tipos de datos Gracias al duck typing, a veces Python puede asumir un tipo de datos que no queremos. Sin embargo, podemos convertir datos.\n# Esto aunque parezca booleano, Python lo entendera como un entero bool_test = 1 print(bool_test) print(type(bool_test)) # Conversion de datos usando bool(), int(), float() real_bool = bool(1) real_int = int(2.0) Entrada por teclado Podemos permitir que el usuario introduzca información usando la función input(). Esta función nos regresará lo que el usuario escribió como cadena de texto.\n# Entrada por teclado usando input() print(\"Escriba su nombre\") nombre = input() # f strings ;) print(f\"Hola, {nombre}\") print(f\"La variable tiene el tipo de dato {type(nombre)}\") Estructuras de datos Una estructura de datos es un formato de organización, manejo y almacenamiento de datos que permite acceder y modificar datos de forma eficiente.\nPython tiene 4 estructuras de datos básicas: listas, sets, tuplas y dictionarios. En este curso sólo veremos listas y diccionarios.\nListas Las listas son estructuras de datos que se usan para guardar ítems en una sola variable. Las listas pueden guardar cualquier tipo de datos.\n# Una lista vacia empty_list = [] str_list = [\"1\", \"2\", \"3\"] int_list = [1, 2, 3] mixed_list = [1, 1.0, \"2\", \"Hola\", True, \"True\", [1, 2]]  Imprimir en pantalla cada una de las listas  # Aqui va tu codigo  ¿Cuántos elementos tiene la lista?  print(len(str_list))  Acceder a los elementos de la lista usando índices  # Todo empieza en cero... print(str_list[0]) print(str_list[3])  Agregar elementos usando append()  str_list.append(\"4\") print(str_list[3])  Eliminar elementos usando remove()  str_list.remove(\"4\") print(str_list) print(str_list[3]) Diccionarios Los diccionarios se usan para guardar datos usando parejas de llaves y valores (key: value). Los diccionarios no permiten repetición de llaves. Tal y como funciona un diccionario físico.\n# Un diccionario vacio empty_dict = {} # Un diccionario de una bolsa de frutas fruit_bag = {'apples': 4, 'pears': 9, \"bananas\": 0} También se puede escribir delimitando espacios (Mira la sangría)\n# Un diccionario de una bolsa de frutas, con espacios fruit_bag = { 'apples': 4, 'pears': 9, \"bananas\": 0 }  Consultar las Keys (Llaves) existentes en el diccionario. Método keys()  print(fruit_bag.keys())  Values (Valores) Método values()  print(fruit_bag.values())  Comprobar si existe una llave en el diccionario  print(\"kiwis\" in fruit_bag)  Acceder a valores usando una llave  # Cuantas manzanas hay? print(fruit_bag[\"apples\"])  Actualizar valores  # Ahora hay 5 manzanas fruit_bag[\"apples\"] = 5 print(fruit_bag)  Agregar nuevas llaves  # Agregando kiwis a la bolsa de frutas fruit_bag[\"kiwis\"] = 1 print(fruit_bag)  Eliminar una llave usando del  # Ya no es temporada de kiwis del fruits['kiwis'] print(fruits) Ejercicios   Crear una variable colegiatura que pida un valor al usuario.\n Imprimir el valor que el usuario introduce Imprimir el tipo de dato que tiene colegiatura Convertir el valor a float    Usando las listas mixed_list y str_list de los ejercicios:\n Agregar el último elemento de la lista str_list a la lista mixed_list Imprimir en pantalla:  Tipo de dato del primer elemento de mixed_list Elemento con índice 6 de de mixed_list   Reto Convertir el elemento con índice 1 de mixed_list a tipo int Reto Verificar si los elementos con índices 0 y 1 de mixed_list y str_listson del mismo tipo    Seguir el ejercicio de frutas en 5.1. More on Lists en el sitio de referencia de Python Estructuras de Datos\n  Crear un diccionario llamado estudiante con 2 llaves:\n “id” “calificacion_final”  Ejercicios:\n Llenar el diccionario con un ejemplo de un estudiante. Reto Llenar el diccionario con 3 estudiantes.    Material adicional  Introducción a la programación con Python. Bartolomé Sintes Marco. Disponible en: https://www.mclibre.org/consultar/python/index.html  ","description":"Ejercicios y tareas del material introductorio a Python","tags":["python"],"title":"1. Introducción a Python","uri":"/datlab/dap101/1-intro/"},{"content":"1 Inicio En esta sección se presentan los requisitos y recomendaciones técnicas para seguir los cursos, así como el detalle de los cambios hechos cada versión del sitio.\n","description":"","tags":null,"title":"Inicio","uri":"/datlab/basics/"},{"content":"Introducción Python es un lenguaje de programación completo que puede realizar distintos tipos de operaciones: matemáticas, lógicas y relacionales. En esta sección veremos los operadores que Python utiliza y cómo usarlos.\nOperaciones matemáticas Suma\nSe indica con el operador +\nprint(2 + 3) Resta\nSe indica con el operador -\nprint(2 - 3) Multiplicación\nSe indica con el operador *\n# Multiplicaciones print(2 * 3) Potencias\nLas potencias se indican con el operador ** (Python no usa ^ para indicar potencias como otros lenguajes)\n# cuidado con el operador... print(2 ** 3) Divisiones\nDependiendo lo que se requiera, las divisiones se indican con el operador /, // o %\n# División print(38 / 5) # Cociente de la división (devuelve un entero) print(38 // 5) # Residuo de la división print(38 % 5) Comparadores / Operadores relacionales Consideremos dos variables, x y y.\n# Dos numeros x = 3 y = 4 Los siguientes operadores devolverán un valor verdadero o falso, dependiendo de la comparación.\nIgualdad\n# Igual que print(x == y) Desigualdad\n# No es igual que  print(x != y) Menor que, estrictamente menor\n# Menor que print(x \u003c y) Mayor que, estrictamente mayor\n# Mayor que print(x \u003e y) Menor o igual que\n# Menor o igual que print(x \u003c= y) Mayor o igual que\n# Mayor o igual que print(x \u003e= y) Operadores lógicos Los operadores lógicos devuelven un resultado si se cumple o no una condición. Los valores a devolver sólo son dos: verdadero o falso. Estos operadores se llaman también booleanos por usar álgebra de Boole.\nand, operador y\nDevuelve un valor verdadero si todas las premisas son verdaderas.\n# Y print(x == y and 5 \u003e= 2) or, operador o\nDevuelve un valor verdadero si al menos una de las premisas es verdadera.\n# O print(x == y or 5 \u003e= 2) not, operador no\nEste operador niega el valor de la premisa. Si el valor de la premisa es verdadero, el operador devolverá un valor falso. Si el valor de la premisa es falso, el operador devolverá un valor verdadero.\n# not z = x == y print(not z) Estructuras de control if if (si, en español) es una sentencia condicional que permite que un programa ejecute un bloque de código si se cumple una condición (si la condición es verdadera).\n# Sintaxis de if if condición: #Aquí va el código que se ejecutará si la condición es verdadera   Sangrías La sangría es la manera natural de Python de definir bloques de código. Las sangrías típicamente se definen con un tab.\nFíjate bien en la sangría una vez que definimos la sentencia if. La sangría define el bloque de código que se ejecutará si dicha condición es verdadera. Si no dejamos la sangría, dicho bloque de código estará fuera del if, y seguramente tendremos errores…\n  El siguiente ejemplo pedirá al usuario que introduzca un número positivo. Después evaluará si el usuario realmente siguió la instrucción.\nnumero = int(input(\"Escribe un número positivo: \")) if numero \u003c 0: print(f\"{numero}no es un número positivo\") print(f\"Ha escrito el número {numero}\") El siguiente ejemplo ahora pide al usuario que escriba un número mayor que 5. Si el usuario escriba un número menor o igual a 5, el programa imprimirá en pantalla un mensaje informando que esta instrucción no se siguió.\nnumero = int(input(\"Escribe un número mayor que 5: \")) if numero \u003c= 5: print(f\"{numero}no es un número estrictamente mayor que 5\") print(f\"Ha escrito el número {numero}\") if … else if … else es una sentencia condicional que permite que un programa ejecute un bloque de código si se cumple una condición (si la condición es verdadera). Si la condición no es verdadera, el programa ejecutará el bloque de código contenido en else.\n# Sintaxis de if else if condición: # Aquí va el código que se ejecutará si la condición es verdadera else: # Aquí va el código que se ejecutará si la condición no es verdadera El siguiente ejemplo es lo que hace parte del personal de seguridad en la entrada a un lugar donde es necesario tener mayoría de edad.\nprint(\"Entrada del BabyO\") edad = int(input(\"¿Cuántos años tiene? \")) if edad \u003c 18: print(\"No puede entrar\") else: print(\"Aunque es mayor de edad, esta lleno...\") if … elif … else elif (contracción de else if) es una estructura de control útil cuando tenemos más de una condición a evaluar. De esta manera, podemos encadenar varias condiciones.\n# Sintaxis de if elif else if condición1: # Aquí va el código que se ejecutará si la condición1 es verdadera elif condición2: # Aquí va el código que se ejecutará si la condición2 es verdadera else: # Aquí va el código si ninguna condición es verdadera El siguiente ejemplo nos dirá cuántos cajeros están disponibles en un banco, considerando el número de clientes que ya están usando un cajero.\n# Multiples condiciones. Un banco con 3 cajeros cajeros = 3 clientes = int(input(\"Escriba el numero de clientes usando un cajero \")) # Calcular cajeros disponibles cajeros_disp = cajeros - clientes if (cajeros_disp == cajeros): print(\"Todos los cajeros estan disponibles!\") elif (1 \u003c= cajeros_disp \u003c cajeros): print(f\"Hay {cajeros_disp}cajeros disponibles\") elif (cajeros_disp == 0): print(f\"No hay cajeros disponibles\") else: print(\"Intenta un número mayor que 0 pero menor o igual a 3\") Funciones Una función es un bloque de código que se ejecuta sólo cuando es llamada o invocada. Se les puede transferir valores utilizando argumentos y a su vez, una función puede devolver valores.\nEstructura de una función\ndef mi_funcion(arg): # Aqui va el codigo return arg def otra_funcion(mensaje): # Aqui va el codigo print(mensaje) Las funciones pueden tener más de un argumento. Todo depende de lo que queramos que el programa realice.\ndef mi_funcion(arg1, arg2): # Guarda los argumentos en una lista arg_list = [arg1, arg2] return arg_list Ejercicios  Escribe una función media que calcule la media de dos números a y b, y que imprima el resultado en pantalla.  def media(a, b): # Aqui va tu codigo  Crea una función temp_convert que tome la temperatura en grados Farenheit tf como argumento y la convierta a grados Celsius. La función deberá mostrar en pantalla la temperatura en grados Celsius.\nPuedes usar la siguiente ecuación para realizar la conversión de temperaturas:\n  $$ T_c = \\frac{5}{9}(T_f - 32)$$\ndef temp_convert(tf): # Aqui va tu codigo   Consejo Puedes usar la función round(x, 2) para redondear el valor de x a 2 decimales.\n  Para verificar tu función, puedes usar las siguientes pruebas:\n   Prueba Resultado     temp_convert(59) 15   temp_convert(32) 0   temp_convert(-40) -40    Crea una función llamada contabilidad que tome una lista pagos con los pagos del mes y una variable ingresos que indica el total de ingresos del mes como argumentos. La función deberá regresar el dinero que queda disponible.  def contabilidad(pagos, ingresos): # Aqui va tu codigo   Consejo Puedes usar la función sum() para sumar todos los elementos de la lista.\n  Para verificar tu función, puedes usar las siguientes pruebas:\n   Prueba Resultado     print(contabilidad([100, 300, 20], 750)) 330   print(contabilidad([300, 39, 700, 500, 220, 740], 2500)) 1    Material adicional  Introducción a la programación con Python. Bartolomé Sintes Marco. Disponible en: https://www.mclibre.org/consultar/python/index.html  ","description":"Operaciones aritméticas. Condicionales. Funciones","tags":["python"],"title":"2. Primer programa en Python","uri":"/datlab/dap101/2-first_program/"},{"content":"DAP101 Análisis de Datos en Python En esta sección encontrarás el contenido y los ejercicios del curso Análisis de Datos en Python\n1. Introducción a Python Ejercicios y tareas del material introductorio a Python\n2. Primer programa en Python Operaciones aritméticas. Condicionales. Funciones\n3. Bucles Bucles: For, While\n4. Manejo de datos Manejo de datos con pandas\n5. Visualización Creación de gráficos y visualizaciones con matplotlib y seaborn\n6. Análisis estadístico Pruebas de hipótesis y regresión\n7. Recapitulación Ejercicio final para recapitular lo aprendido en el curso\n ","description":"","tags":null,"title":"Análisis de Datos en Python","uri":"/datlab/dap101/"},{"content":"Esta sección muestra las últimas novedades de la versión más reciente de este sitio. Para una lista más detallada, ver la página Historia.\nAnálisis de Datos en Python - Ejercicios y tareas Estaré impartiendo un curso de Análisis de Datos en Python en una universidad local el siguiente mes. Como primer proyecto de este sitio, subiré aquí los ejercicios y las tareas.\nEspero que con este primer curso, podamos impartir muchos más y compartir conocimiento a más personas \nDat Lab, ahora con Relearn Después de batallar un poco con unos bugs de Learn, decidí usar Relearn. Además que tiene funcionalidades más agradables para el usuario final.\nFinalmente, decidí cambiar el nombre del sitio a algo más genérico: Dat Lab.\nDat Lab, es un juego de palabras entre Dat, una abreviatura coloquial e informal de Data, y Lab, laboratorio. Entonces Dat Lab es el Laboratorio de Datos… , o también “Ese laboratorio” o, “Ese lab de datos…” \n","description":"","tags":null,"title":"Novedades","uri":"/datlab/basics/migration/"},{"content":"Introducción Un bucle es estructura de control que repite un bloque de código con instrucciones una y otra vez. Los bucles pueden ser finitos (se repiten un determinado número de veces) o infinitos.\nBucles For For es un bucle finito, puesto que definimos el inicio y el fin. Típicamente se usan cuando conocemos la cantidad de veces que deseamos repetir instrucciones.\nPor ejemplo, cuando queremos acceder a una lista por sus elementos.\n# Una lista con numeros a = [1, 2, 10, 0, 6] for element in a: print(element) Range\nRange es un tipo de datos especial que representa una secuencia de números. Se puede utilizar para especificar la cantidad de veces que el bucle For se ejecuta.\nrange(j) # 0, 1, 2, ..., j-1 range(i, j) # i, i+1, i+2, ..., j-1 range(i, j, k) # i, i+k, i+2k, ..., j-1 Algunos ejemplos:\nrange_list = list(range(5)) print(range_list) ten_hundred = list(range(10, 101, 10)) print(ten_hundred) Usemos ahora range para acceder a los elementos de la lista usando índices.\n# Ahora usamos indice for i in range(len(a)): print(a[i]) Ejercicio\n Usando un bucle For, calcular la media de un estudiante con las siguientes calificaciones:     Materia Calificaciones     Quimica 9   Biologia 8   Matematicas 9.5   Psicologia 8.5     Consejo Representa las calificaciones como una lista. Primero sumar y al final, dividir.\n$$ \\bar{x} = \\frac{1}{N}\\sum_{i=1}^N x $$\n  # Aqui va tu codigo While While es un bucle de tipo infinito. En él, se repite la ejecución de un bloque de instrucciones mientras se satisfaga una condición.\nEl siguiente ejemplo imprimirá en pantalla el número 0 tres veces.\ni = 1 while i \u003c= 3: print(0) i += 1 print(\"Hasta que se acabe el dedo\") Otro ejemplo.\ni = 10 while i \u003e= 0: print(i) i -= 1 print(\"Cuenta terminada\") Un infinito (Definimos mal la condición a satisfacer)\ni = 1 while i \u003c= 10: print(i) Casi infinito.\n# Are you human? print(\"¿Eres una persona? Responde Si o No\") answer = input().lower() while(answer == \"si\"): print(\"¿En serio? Intenta otra vez. Responde Si o No\") answer = input().lower() Podemos romper un bucle while con break\ndef break_loop(): contador = 0 while True: print(\"¿Deseas terminar el programa? Escribe Si o No\") respuesta = input() # Actualizar el contador contador += 1 if contador \u003e= 5: print(\"Ya me ejecuté muchas veces. Voy a descansar.\") break Ejercicios Aprobado / No Aprobado Consideremos el caso de un estudiante que tiene que presentar tres exámenes. La escala de evaluación es de 0 a 100 puntos.\nUn estudiante aprueba el año si:\n Se aprueban todos los exámenes con 40 puntos o más, o Se aprueban al menos dos exámenes con 40 puntos o más, y que la media de los tres exámenes sea estrictamente mayor a 50. (Es decir, una media de 50 puntos no es aprobatoria).  Escribe una función student_pass que tome tres argumentos, las calificaciones de los exámenes (como enteros), y determinar si el estudiante ha aprobado el año, utilizando dichas calificaciones. La función debería imprimir “Aprobado” o “No aprobado”.\nPuedes utilizar la siguientes pruebas para verificar tu función:\n   Prueba Resultado     student_pass(70, 50, 30) “No aprobado”   student_pass(70, 50, 35) “Aprobado”    “Dile que no” Escribe un programa que imprima en pantalla la pregunta\n“¿Desea continuar el programa?:”\nY que termine el programa solo cuando el usuario escriba “no”.\ndef dile_no(): # Aqui va tu codigo ","description":"Bucles: For, While","tags":["python"],"title":"3. Bucles","uri":"/datlab/dap101/3-loop/"},{"content":"Introducción pandas es la librería de Python más utilizada para procesar datos. pandas puede leer datos de archivos CSV, JSON, txt, xls, xlsx, entre otros. La estructura de datos más común de esta librería es DataFrame, que es una estructura de datos tabular bidimensional con ejes etiquetados (filas y columnas).\nDatos\nUsaremos los siguientes archivos para los ejercicios de este tema:\n Archivos estudiantes_mxuk.csv (9 KB) inah_visitantes_2022.csv (19 KB)   Primeros pasos Creamos un Jupyter notebook y creamos un cuadro con código. Analizaremos el archivo inah_visitantes_2022.csv.\nEste archivo contiene la información de visitantes a museos y zonas arqueológicas manejadas por el INAH durante el año 2022. La descripción de las columnas es la siguiente:\n   Variable Tipo variable Descripción de la variable     Estado Cadena de texto Estado de la República donde se encuentra el centro INAH   Clave_SIINAH Numérica Clave interna asociada al centro INAH   Tipo Cadena de texto Tipo de centro. Z.A. - Zona arqueológica. M. M.H. - Museo o Museo histórico   Clave_SIINAH Numérica Clave interna asociada al centro INAH   Centro_INAH Cadena de texto Nombre del centro INAH   Enero_nac Numérica Número de visitantes nacionales en el mes de enero   Enero_ext Numérica Número de visitantes extranjeros en el mes de enero   Febrero_nac Numérica Número de visitantes nacionales en el mes de febrero   Febrero_ext Numérica Número de visitantes extranjeros en el mes de febrero   Marzo_nac Numérica Número de visitantes nacionales en el mes de marzo   Marzo_ext Numérica Número de visitantes extranjeros en el mes de marzo    Importar datos Importamos el CSV usando el método read_csv(). El nombre del archivo debe ir entre comillas.\nimport pandas as pd # Leer el CSV y procesarlo como dataframe inah_visitantes2022 = pd.read_csv(\"inah_visitantes_2022.csv\") inah_visitantes2022 es un objeto DataFrame que contiene los datos de este CSV.\nPodemos ver lo que contiene el dataframe:\n# Miramos lo que contiene el dataframe inah_visitantes2022 head or tail Ver sólo ver las primeras n filas con el método head(). O las últimas n filas con el método tail().\n# ver las primeras 5 filas inah_visitantes2022.head(5) # ver las últimas 5 filas inah_visitantes2022.tail(5) Resumen general El método info() muestra información general del DataFrame como el tipo de datos que contiene la columna, conteo de valores no nulos y uso de memoria.\n# Informacion general inah_visitantes2022.info() Dimensiones Para inspeccionar las dimensiones de los datos importados, usamos el atributo shape.\n# Dimensiones inah_visitantes2022.shape Esto nos devuelve una tupla (277, 10) que contiene el numero de (filas, columnas) de este DataFrame.\nColumnas Para inspeccionar el nombre de las columnas, usamos el atributo columns.\n# Columnas inah_visitantes2022.columns Ordenar datos Podemos ordenar datos usando el método sort_values().\nEn el siguiente ejemplo, ordenamos por una columna, en orden ascendente.\n# Ordenar por una sola columna, \"enero_nac\". ascending = True por defecto inah_visitantes2022.sort_values(by=['enero_nac']) También podemos ordenar por más de una columna, en orden descendente.\n# Ordenar por \"enero_nac, febrero_nac\" en orden descendente inah_visitantes2022.sort_values(by=['enero_nac', 'febrero_nac'], ascending = False) DataFrame vs Series Selección de columnas Podemos crear un DataFrame más pequeño sólo con algunas columnas.\n# Un dataframe con datos nacionales inah_visitantes_nac = inah_visitantes2022[[\"Centro INAH\", \"enero_nac\", \"febrero_nac\", \"marzo_nac\"]] # Mostrar 5 primeras filas inah_visitantes_nac.head(5) Series Una serie es un arreglo unidimensional de datos (vector columna).\n# Una serie con los datos de los centros INAH centros_inah = inah_visitantes2022[\"Centro INAH\"] centros_inah # Series pueden ser convertidas a lista enero_nac = inah_visitantes2022[\"enero_nac\"].to_list() Estadística descriptiva DataFrame Accedemos a las siguientes medidas descriptivas de los datos usando el método describe():\n Conteo Media Desviación típica Valor mínimo Primer cuartil (25%) Segundo cuartil o mediana (50%) Tercer cuartil (75%) Valor máximo  # Mostrar estadistica descriptiva de un DataFrame inah_visitantes2022.describe() Series Para una serie con valores numéricos, se reportan las mismas medidas que en un DataFrame. Pero para una serie con valores de texto, se reportan:\n Conteo Valores únicos Top (Valor más frecuente) Frecuencia  # Mostrar estadistica descriptiva de una Serie inah_visitantes2022[\"Estado\"].describe() Operaciones Hemos visto hasta ahora como importar datos y ver sus medidas de estadística descriptiva, pero también podemos realizar operaciones con los DataFrames.\nCrear columnas Crear columnas es tan simple como declarar el nombre de la columna y los valores que queremos guardar en esta columna.\nPor ejemplo, creemos la columna “prueba_columna” en el DataFrame de visitantes a centros INAH. Le asignaremos a esta columna un valor arbitrario.\ninah_visitantes2022[\"prueba_columna\"] = 1 Lo que hizo este instrucción fue crear la columna y asignar a todas las filas el valor de 1. Pero, también podemos crear columnas usando valores de otras columnas usando operaciones matemáticas.\nCreemos una nueva columna llamada enero_visitantes que contenga la suma de todos los visitantes (tanto nacionales como extranjeros) de cada centro INAH en el mes de enero.\n# enero_visitantes es la suma de visitantes nacionales y visitantes extranjeros inah_visitantes2022[\"enero_visitantes\"] = inah_visitantes2022[\"enero_nac\"] + inah_visitantes2022[\"enero_ext\"] Eliminar columnas Para eliminar columnas innecesarias o que fueron creadas por error, se puede hacer con el método drop().\nLa sintaxis es la siguiente:\ndf = df.drop(columns) donde el argumento columns puede aceptar un valor único con el nombre de la columna, o una lista con los nombres de columnas a eliminar.\nPara eliminar la columna que acabamos de crear, introducimos la siguiente instrucción:\ninah_visitantes2022 = inah_visitantes2022.drop(columns = \"prueba_columna\") Crear columnas usando funciones Para usar una función basada en una columna podemos usar el método map().\nLa sintaxis es la siguiente:\n# Sintaxis de map df['nueva_col'] = df['col'].map(funcion) Tenemos la siguiente función que escribe una cadena de texto si la columna tiene valores de 0 o distintos de 0.\ndef test_function(col): if col == 0: col = \"No visitantes\" else: col = \"Visitantes\" return col Usemos map para aplicar esta función a una nueva columna “respuesta”.\ninah_visitantes2022[\"respuesta\"] = inah_visitantes2022[\"enero_nac\"].map(test_function) inah_visitantes2022.head()   Información Si la función es más compleja y requiere más de una columna, está el método apply().\n  Selección de datos Podemos hacer una selección de datos del DataFrame, dependiendo si queremos ver un subconjunto que satisfaga una o más condiciones, o la ubicación dentro del DataFrame.\nCondicionales  Una condición  # Sintaxis df[df[\"columna\"] condición] donde la condición puede ser una igualdad ==, diferente de !=, mayor o igual \u003e=, menor o igual \u003c=, estrictamente mayor \u003e o estrictamente menor \u003c.\n# Mostrar datos solo para el estado Guerrero inah_visitantes2022[inah_visitantes2022[\"Estado\"] == \"Guerrero\"] # Mostrar centros con más de 1000 visitantes nacionales en enero inah_visitantes2022[inah_visitantes2022[\"enero_nac\"] \u003e= 10000] Múltiples condiciones  # Sintaxis df[(df[\"columna\"] condición1) operador_lógico (df[\"columna\"] condición2) ... ] donde el operador lógico puede ser \u0026 (operador “y”) o | (operador “o”)\n# Mostrar los centros con más de 1000 visitantes nacionales en Guerrero inah_visitantes2022[(inah_visitantes2022[\"Estado\"] == \"Guerrero\") \u0026 (inah_visitantes2022[\"enero_nac\"] \u003e 1000)]  Múltiples valores a comparar de una misma columna  El método isin() nos permite utilizar una lista para comparar valores.\n# Sintaxis df[df[\"columna\"].isin(lista)] Mostrar los centros con más de 1000 visitantes nacionales en Guerrero y Quintana Roo en el mes de marzo.\n# Seleccion de centros en Guerrero y Quintana Roo usando el metodo isin inah_visitantes2022[(inah_visitantes2022[\"Estado\"].isin([\"Guerrero\", \"Quintana Roo\"])) \u0026 (inah_visitantes2022[\"marzo_nac\"] \u003e 1000)] Query  Cuando se tienen más de una condición, query() puede ser más elegante.\n# Sintaxis df.query('expresion') Para seleccionar los datos de centros INAH del estado de Guerrero con visitantes nacionales en enero mayores o igual a 1000, podriamos escribirlo como en el ejemplo 2, o usando query:\n# Seleccion usando query inah_visitantes2022.query('Estado == \"Guerrero\" \u0026 enero_nac \u003e= 1000') Ver valores por su label, o utilizando con condiciones, .loc loc es una propiedad que nos permite ver valores usando el label (o índice) de las filas, o usar condiciones para generar vistas.\n# Vistas por condiciones. Tambien se pueden definir cuantas columnas mostrar inah_visitantes2022.loc[inah_visitantes2022[\"Estado\"] == \"Guerrero\", [\"enero_nac\", \"febrero_nac\"]] Parece igual…\n# Un DataFrame con labels en lugar de indices df_label = pd.DataFrame([[1, 2], [4, 5], [7, 8]], index=['cobra', 'viper', 'sidewinder'], columns=['max_speed', 'shield']) # loc, vistas por label df_label.loc[\"cobra\"] Ver valores por índices, .iloc iloc es una propiedad que nos permitirá acceder a filas y columnas usando sus índices.\n# Sintaxis general df.iloc[fila_a: fila_b, columna_a: columna_b]  Una fila  # Primera fila, una serie inah_visitantes2022.iloc[0] # Primera fila, pero un dataframe inah_visitantes2022.iloc[[0]] Más de una fila, en desorden  # Más de una fila, en distinto orden inah_visitantes2022.iloc[[7, 2, 0]] Celdas  # Celda ubicada en la fila 0, columna 3 inah_visitantes2022.iloc[0,3] Mostrar una selección de filas, en orden.  # Mostrar las filas 0, 1 y 2 inah_visitantes2022.iloc[0:3] Mostrar selección de filas y de columnas  # Mostrar las primeras (0:2) filas, las primeras 3 columnas (0:3) inah_visitantes2022.iloc[0:2,0:3] Agrupación de datos groupby() es un método que permite agrupar datos por columnas y crear un DataFrame más compacto.\n# Sintaxis df.groupby(by = \"columna\").funcion() Se requiere que definamos una función para que pandas pueda aplicar una operación matemática para presentar los valores agrupados. La función puede ser:\n count() – Conteo sum() – Suma mean() – Media median() – Mediana min() – Valor mínimo max() – Valor máximo std() – Desviación tipica var() – Varianza  # Agrupar datos por estado, sumando valores inah_visitantes2022.groupby(by = \"Estado\").sum() Remodelación usando “Melt” A veces necesitaremos de “masajear” un DataFrame para convertir de un formato ancho a un formato largo. Esto se logra con el método melt(). Este tipo de remodelación de DataFrames es de utilidad cuando se tienen una o más columnas que pueden ser usadas como identificadores, y las demás columnas como valores.\n# Remodelando el df pd.melt(inah_visitantes2022) Ejercicios Usando los datos en estudiantes_mxuk.csv, contestar las siguientes preguntas.\n ¿Cuántos estudiantes de Puebla estudian un posgrado? ¿Cuál es la edad promedio de los estudiantes que estudian un posgrado? Seleccionar los registros que satisfagan las siguientes condiciones:  Estudiantes mayores de 27 años y que no son de CDMX. Estudiantes menores de 28 años y, que estudian en University of York y en University of Sussex.   Calcular (tal vez sea útil usar groupby()):  Número de estudiantes por universidad Número de estudiantes por estado ¿Cuál es la universidad con más estudiantes mexicanos?    Referencias   Visitantes a museos y zonas arqueologicas abiertas al público. Datos abiertos de México. Disponible en: https://datos.gob.mx/busca/dataset/visitantes-a-museos-y-zonas-arqueologicas-abiertas-al-publico\n  Estudiantes de posgrado en el Reino Unido. Sin publicar.\n  Filtrado y uso de query con pandas en Python. Naps Tecnología y educación. Disponible en: https://naps.com.mx/blog/uso-de-query-con-pandas-en-python/\n  Pandas I. Curso Ciencia de Datos con Python CIDE. Disponible en: https://rafneta.github.io/CienciaDatosPythonCIDE/Laboratorios/Lab9/PandasI.html\n  pandas documentation. the pandas development team. Disponible en: https://pandas.pydata.org/pandas-docs/stable/\n  How to use iloc and loc for indexing and slicing pandas dataframes. Marsja. Disponible en: https://www.marsja.se/how-to-use-iloc-and-loc-for-indexing-and-slicing-pandas-dataframes/\n  ","description":"Manejo de datos con pandas","tags":["pandas"],"title":"4. Manejo de datos","uri":"/datlab/dap101/4-pandas/"},{"content":"Introducción La información que hemos procesado previamente se puede visualizar usando gráficos. En esta sección veremos como crear gráficos profesionales con matplotlib y seaborn.\nDatos\nUsaremos los siguientes archivos para los ejercicios de este tema:\n Archivos aspirantes_inecol2020.csv (1 KB) estudiantes_mxuk.csv (9 KB) inah_visitantes_2022.csv (19 KB)   Librerías\nUsaremos las siguientes librerías para los ejercicios de este tema:\nimport pandas as pd import matplotlib.pyplot as plt import seaborn as sns plt.rcParams[\"figure.figsize\"] = (10,8) # Definicion de tamaño en pulgadas Descripción de datos\nEstos son datos abiertos de aspirantes a posgrados ofrecidos en el Instituto de Ecología, A.C. (INECOL). La descripción de las columnas es la siguiente:\n   Columna Tipo de dato Descripción     id_aspirante Numérico Número de identificación interno asignado al aspirante   calificacion_ingles Numérico Calificación obtenida en prueba de inglés. Escala 0 - 10   calificacion_conocimientos_tecnicos Numérico Calificación obtenida en prueba conocimientos técnicos. Escala 0 - 10   entrevista Numérico Calificación obtenida en entrevista. Escala 0 - 10   desempeno_academico Numérico Calificación obtenida por desempeño académico. Escala 0 - 10   calificacion_final Numérico Calificación final asignada al aspirante. Escala 0 - 10   resultado Texto Resultado del proceso de admisión    matplotlib matplotlib es una librería de bajo nivel, es decir, necesitamos definir muchas cosas, pero tendremos más libertad y flexibilidad en nuestros gráficos. Revisaremos las gráficas de dispersión en este paquete.\nDispersión Vamos a utilizar datos artificiales de una variable x, y creamos dos funciones de x.\nimport numpy as np # Libreria para acceder a funciones matematicas x = np.linspace(-3, 3, 100) # crear 100 valores en un rango -3 a 3 y1 = 3*x y2 = x**3 + x**2 - x + 1 # Crear un grafico con ambas curvas en el mismo eje fig, ax = plt.subplots() ax.plot(x, y1, 'g--', label=r'$y_1$') # Trazos ax.plot(x, y2, 'y.', label=r'$y_2$') # Puntos # .legend() utiliza el argumento \"label\" para cada curva ax.legend(loc='lower right', fontsize=14) # Mostrar el grafico plt.show() seaborn seaborn es una librería basada en matplotlib, pero es de alto nivel. Es decir, no tendremos que escribir tanto para crear gráficos.\nAhora usaremos los datos de aspirantes a posgrado de INECOL, que están en el archivo aspirantes_inecol2020.csv.\n# Importar datos aspirantes INECOL inecol_df = pd.read_csv(\"aspirantes_inecol2020.csv\") Pairplot Este gráfico nos puede server para encontrar relaciones entre variables y como primer paso en nuestro análisis de datos.\n# Dale unos segundos... sns.pairplot(inecol_df) Gráfico de dispersión En lugar de escribir un montón de código, seaborn tiene un método que simplifica esta tarea. Al ser un gráfico de dispersión, no une los puntos.\n# Dispersion sns.scatterplot(data = inecol_df, x = \"calificacion_ingles\", y = \"calificacion_final\") Gráfico de línea Este gráfico es similar al de dispersión, pero en este gráfico, seaborn une los puntos. Debido a que las medidas pueden ser ruidosas, seaborn estima la tendencia central de los datos y es lo que nos muestra trazado en una línea. Además, muestra el intervalo de confianza de 95% de dicha tendencia.\n# Lineplot sns.lineplot(data = inecol_df, x = \"calificacion_ingles\", y = \"calificacion_final\") Esta gráfica puede graficar la desviación típica, en lugar del intervalo de confianza, usando el argumento ci = \"sd\", o no mostrar nada con ci = None.\nHistograma # Sintaxis sns.histplot(data = df, x = \"columna\", stat, kde) Un ejemplo de un histograma utilizando porcentaje como medida estadística.\nsns.histplot(data = inecol_df, x = \"calificacion_final\", stat = \"percent\") La medida estadística stat utilizada en el eje puede ser:\n count: número de observaciones en cada segmento frequency: muestra el número de observaciones dividido entre el “ancho” (intervalo) del segmento probability: normaliza el eje para que la altura de las barras sumen 1 percent: normaliza el eje para que la altura de las barras sumen 100 density: normaliza el eje para que el total del área del histograma sea 1  kde es un parámetro opcional donde podemos obtener una distribución estimada de los datos. Para activarlo pasamos el siguiente argumento cuando creemos el objeto histoplot: kde = True\nDiagramas de caja y bigotes (boxplot) Muestra la distribución de datos cuantitativos utilizando sus medidas de localización.\n# Ver la distribución de calificaciones finales de los aspirantes con boxplot # (Se ve mejor así, que si invirtieramos los ejes...) sns.boxplot(data = inecol_df, y = \"resultado\", x = \"calificacion_final\", whis = 1.5) whis es un parámetro opcional que define la extensión de los “bigotes” de las cajas, respecto al rango intercuartílico. En el ejemplo de arriba, 1.5 es 1.5 veces el rango intercuartílico.\nDiagrama de violín Visualización combinada de un diagrama de cajas y de la distribución estimada de los datos.\n# Ver la distribución de calificaciones finales de los aspirantes con violinplot sns.violinplot(data = inecol_df, y = \"resultado\", x = \"calificacion_final\") Gráfico de barras Podemos agrupar los datos usando la columna “resultado”, contando el número de registros.\n# Agrupar por Resultado y recrear el indice inecol_resultado = inecol_df.groupby(by = \"resultado\").count() # Recrear el indice para que \"resultado\" no sea indice inecol_resultado = inecol_resultado.reset_index()   ¿Por qué reset_index()? Al agrupar los valores con groupby(), la columna usada como argumento de by se convierte en el índice del DataFrame compacto.\nSi deseamos que el índice sea numérico y no la columna, la función reset_index()  nos sirve para recrear el índice numérico.\n  # Gráfico de barras resumiendo el resultado final de aspirantes sns.barplot(data = inecol_resultado, y = \"resultado\", x = \"calificacion_final\") Usando los datos del INAH, creemos un gráfico de barras el número de centros INAH por estado.\n# Usando los datos de visitantes a los centros INAH en 2022 inah_df = pd.read_csv(\"inah_visitantes_2022.csv\") # Agrupando por estado y usando la función count() inah_grouped = inah_df.groupby(by = \"Estado\").count() inah_grouped = inah_grouped.reset_index() # Para que Estado no sea índice/label # Mostrar grafico sns.barplot(data = inah_grouped, x = \"Tipo\", y = \"Estado\")   Histograma vs gráfico de barras Ambos gráficos parecen iguales, ambos usan barras, pero no son lo mismo.\nUn histograma es un diagrama que muestra la frecuencia de datos numéricos, mientras que el gráfico de barras compara tamaños de diferentes variables categóricas.\n  Edición de gráficos Modificar etiquetas de los ejes y exportar imagen como PNG.\n# Declarar el grafico ax = sns.barplot(data = inah_grouped, x = \"Tipo\", y = \"Estado\") # Modificar las etiquetas de los ejes ax.set_xlabel(\"Estado\", fontsize = 12) ax.set_ylabel(\"Número de Centros INAH\", fontsize = 12) # Ajustes para exportar imagen plt.tight_layout() plt.savefig('barplot_inah.png') # Mostrar imagen plt.show() Girar ejes para mejorar la visualización.\n# Misma boxplot de calificaciones de INECOL pero ahora los ejes invertidos sns.boxplot(data = inecol_df, x = \"resultado\", y = \"calificacion_final\", whis = 1.5) # Rotamos las etiquetas del eje x, 45 grados plt.xticks(rotation=45) plt.show() Ejercicios   Usando los datos estudiantes_mxuk.csv, crear gráficos que muestren:\n Distribución de edad por universidad. Becas que tienen los estudiantes.    Usando los datos inah_visitantes_2022.csv:\n ¿Cuál es la visualización más representativa para mostrar el flujo de visitantes en los meses reportados para un Centro INAH (o estado!) determinado?    Referencias y material adicional   Visitantes a museos y zonas arqueologicas abiertas al público. Datos abiertos de México. Disponible en: https://datos.gob.mx/busca/dataset/visitantes-a-museos-y-zonas-arqueologicas-abiertas-al-publico\n  Selección de aspirantes. Datos abiertos de México. Disponible en: https://datos.gob.mx/busca/dataset/seleccion-de-aspirantes\n  Estudiantes de posgrado en el Reino Unido. Sin publicar.\n  The Python graph gallery. Disponible en: https://python-graph-gallery.com/\n  seaborn documentation. Michael Waskom. Disponible en: https://seaborn.pydata.org/\n  ","description":"Creación de gráficos y visualizaciones con matplotlib y seaborn","tags":["visualizaciones","matplotlib","seaborn","pandas"],"title":"5. Visualización","uri":"/datlab/dap101/5-visualizacion/"},{"content":"Introducción Python tiene bastantes librerías para realizar análisis estadístico. En esta sección nos concentraremos en SciPy y statsmodels.\nDatos\nUsaremos los siguientes archivos para los ejercicios de este tema:\n Archivos edadpesograsas.txt (266 B) precipitacion_guerrero.csv (3 KB)   Librerías\nPara esta sección usaremos las siguientes librerías:\nimport pandas as pd import matplotlib.pyplot as plt import seaborn as sns import scipy.stats as stats Datos de precipitación\nUsaremos el archivo precipitacion_guerrero.csv que contiene datos históricos mensuales y anuales de precipitación en Guerrero desde 1985 hasta 2020. Estos datos usan comas para separar miles.\n# Datos precipitacion precipitacion = pd.read_csv(\"precipitacion_guerrero.csv\", thousands = \",\") Inspeccionamos las medidas de estadística descriptiva.\n# Estadistica descriptiva precipitacion.describe() Prueba de normalidad Podemos observar normalidad utilizando histogramas como los que ofrece seaborn, pero también podemos comprobar normalidad usando SciPy.\nSciPy ofrece varias pruebas de normalidad, por ahora veremos la prueba Shapiro-Wilk y D’Agostino-Pearson en sus funciones stats.shapiro y stats.normaltest respectivamente.\nAmbas pruebas se definen con las siguientes hipótesis:\nHipotesis nula: $$H_{0}: \\text{La muestra proviene de una distribución normal} $$\nHipotesis alternativa: $$H_{1}: \\text{La muestra no proviene de una distribución normal} $$\n# Sintaxis de prueba de Shapiro-Wilk stats.shapiro(muestra) # Sintaxis de prueba D'Agostino-Pearson stats.normaltest(muestra) Para ambas pruebas, SciPy nos retornará el valor del estadístico y el valor-p\nHagamos una función para hacer prueba de normalidad con ambos métodos.\ndef normal_test(datos, option = \"shapiro\"): if option != \"shapiro\": test = stats.normaltest(datos) else: test = stats.shapiro(datos) if test.pvalue \u003c 0.05 : print(\"Rechazar hipotesis nula\") else: print(\"No hay evidencia suficiente para rechazar hipotesis nula\") print(test) Ahora comprobemos si los datos de precipitación del mes de julio provienen de una distribución normal.\n# Prueba D'Agostino-Pearson normal_test(precipitacion[\"JUL\"], \"dagostino\") Pruebas de hipótesis t-test Una muestra Esta prueba nos sirve para determinar si la media de la población estudiada es igual a un valor conocido.\n$$\\mu = \\mu_{0}$$\nDefinimos la hipótesis nula como:\n$$H_{0}: \\mu = \\mu_{0} $$\nDependiendo el tipo de hipótesis alternativa, podemos tener las siguientes opciones:\n$$H_{0}: \\mu \\neq \\mu_{0} \\ \\ \\ (\\text{dos colas}) $$\n$$H_{0}: \\mu \u003c \\mu_{0} \\ \\ o \\ \\ \\mu \u003e \\mu_{0} \\ \\ \\ (\\text{una cola}) $$\nUtilizaremos la función ttest_1samp de SciPy.\n# sintaxis stats.ttest_1samp(a, popmean, alternative) donde\na: Muestra\npopmean: Valor de media conocido.\nalternative: Parámetro opcional donde se define la hipótesis alternativa. Las opciones disponibles son ’two-sided’ (dos colas), ’less’ y ‘greater’. El valor predeterminado es ’two-sided’.\nHagamos una función para realizar la prueba de hipótesis.\ndef t_test_1samp(datos, media): test = stats.ttest_1samp(datos, popmean = media) if test.pvalue \u003c 0.05: print(\"Rechazar hipótesis nula\") else: print(\"No hay evidencia suficiente para rechazar hipótesis nula\") print(test) Probemos si la media de precipitación en julio es igual a 150.\nt_test_1samp(precipitacion[\"JUL\"], 150) Dos muestras independientes Esta prueba nos sirve para comparar las medias de dos muestras independientes a y b, y determinar si son iguales.\n$$\\mu_{a} = \\mu_{b}$$\nDefinimos la hipótesis nula como:\n$$H_{0}: \\mu_{a} = \\mu_{b} $$\nDependiendo el tipo de hipótesis alternativa, podemos tener las siguientes opciones:\n$$H_{1}: \\mu_{a} \\neq \\mu_{b} \\ \\ \\ (\\text{dos colas}) $$ $$H_{1}: \\mu_{a} \u003c \\mu_{b} \\ \\ o \\ \\ \\mu_{a} \u003e \\mu_{b} \\ \\ \\ (\\text{una cola}) $$\nUtilizaremos la función ttest_ind de SciPy.\n# sintaxis stats.ttest_ind(a, b, equal_var, alternative) donde\na y b: Muestras a contrastar\nequal_var: Parámetro opcional que define si las muestras tienen varianzas iguales.En caso de que sean iguales, SciPy hará la prueba de hipótesis usando la prueba t-Student. Si las varianzas no son iguales, SciPy usará la prueba Welch. El valor predeterminado es True.\nalternative: Parámetro opcional donde se define la hipótesis alternativa. Las opciones disponibles son ’two-sided’, ’less’ y ‘greater’. El valor predeterminado es ’two-sided’.\nSciPy nos retornará el estadístico y el valor-p.\nHagamos una pequeña función.\ndef t_test(muestra_a, muestra_b, equal_var): t_test = stats.ttest_ind(a = muestra_a, b = muestra_b, equal_var= equal_var) if t_test.pvalue \u003c 0.05: print(\"Rechazar hipótesis nula\") else: print(\"No hay evidencia suficiente para rechazar hipótesis nula\") print(t_test) Probemos contrastando las medias de precipitación de enero y marzo.\nt_test(precipitacion[\"ENE\"], precipitacion[\"MAR\"], True) Ahora probemos contrastando las medidas de precipitación de enero y julio. Es importante recordar que la varianza entre ambos meses no es igual.\nt_test(precipitacion[\"ENE\"], precipitacion[\"JUL\"], False) Dos muestras dependientes (Prueba t pareada) Esta prueba nos sirve para comparar las medias de dos muestras dependientes a y b, y determinar si son iguales. Se considera que dos muestras son dependientes o pareadas cuando existe una relación entre las observaciones. Por ejemplo:\n Comprobar el nivel de satisfacción del mismo grupo de clientes, antes y después, de cambiar detalles en el servicio. Comparar el progreso del mismo grupo de pacientes, antes y después, de introducir un medicamento en su tratamiento.  En esta prueba se contrasta la diferencia entre las medias $\\mu_d$. Si son iguales, la diferencia será igual a 0.\nEntonces, las hipótesis contrastadas son:\n$$H_{0}: \\mu_{d} = 0$$ $$H_{1}: \\mu_{d} \\neq 0$$\nEs importante destacar que para que este tipo de pruebas sean relevantes, los datos deben provenir de una distribución normal. Sin embargo, no es necesario que las varianzas sean iguales.\nSciPy tiene la función ttest_rel para realizar este tipo de pruebas.\n# sintaxis stats.ttest_rel(a, b, alternative) donde\na y b: Muestras a contrastar.\nalternative: Parámetro opcional donde se define la hipótesis alternativa. Las opciones disponibles son ’two-sided’, ’less’ y ‘greater’. El valor predeterminado es ’two-sided’.\nEscribimos una función para realizar esta prueba.\ndef t_test_dep(muestra_a, muestra_b): t_test = stats.ttest_rel(a = muestra_a, b = muestra_b) if t_test.pvalue \u003c 0.05: print(\"Rechazar hipotesis nula\") else: print(\"No hay evidencia suficiente para rechazar hipotesis nula\") print(t_test) Probemos esta función con los valores de medias de precipitación en julio. Dividiremos la columna en dos series. Una serie para años anteriores a 2003, y otra serie para años posteriores a 2003.\n# Obtenemos los valores de precipitacion en julio, y los dividimos en dos partes julio_85_02 = precipitacion.query('PERIODO \u003c= 2002')[\"JUL\"] julio_03_20 = precipitacion.query('PERIODO \u003e= 2003')[\"JUL\"] Ahora, probemos nuestra función.\n# H0: La diferencia de medias es igual a 0 # H1: La diferencia de medias no es igual a 0 t_test_dep(julio_85_02, julio_03_20) Prueba de Levene (Homogeneidad de varianzas) La prueba de Levene es una prueba utilizada para evaluar la igualdad (homogeneidad) de las varianzas para una variable calculada para dos o más grupos. La prueba de Levene está definida como:\n$$H_{0}: \\sigma_{a} = \\sigma_{b} = \\sigma_{c} = … $$ $$H_{1}: \\sigma_{a} \\neq \\sigma_{b} \\neq \\sigma_{c} \\neq … \\ \\ \\text{para al menos un par} $$\nSciPy tiene implementada esta prueba en su función stats.levene.\n# Sintaxis stats.levene(*muestras, center) donde\nmuestras: las muestras a contrastar sus varianzas\ncenter: este parámetro indica la medida de localización para centrar las muestras. Los valores posibles son:\n  median - para muestras que provienen de distribuciones asimétricas. Este es el valor predeterminado.\n  mean - para muestras que provienen de distribuciones simétricas\n  trimmed - para muestras que provienen de distribuciones con colas largas (p. ej. distribución Cauchy)\n  SciPy nos retornará el estadístico y el valor-p.\nHagamos una pequeña función para verificar si las varianzas de la precipitación promedio de los meses enero y marzo son iguales.\ndef levene_test(muestra_a, muestra_b, center): levene_test = stats.levene(muestra_a, muestra_b, center= center) if levene_test.pvalue \u003c 0.05: print(\"Rechazar hipotesis nula\") else: print(\"No hay evidencia suficiente para rechazar hipotesis nula\") print(levene_test) Como prueba de cordura, veamos las distribuciones de la precipitación en ambos meses usando histogramas.\nsns.histplot(precipitacion[\"ENE\"]) sns.histplot(precipitacion[\"MAR\"]) Ahora hagamos la prueba de Levene.\nlevene_test(precipitacion[\"ENE\"], precipitacion[\"MAR\"], \"median\") Regresión lineal La regresión lineal es un instrumento matemático usado para modelar las relaciones entre una variable dependiente (o variable de respuesta), y una o más variables independientes (o variables explicatorias). El modelo lineal tiene la siguiente forma,\n$$y = \\beta_{0} + \\beta_{i}x_i + … + \\epsilon_i \\ \\ \\ \\ \\ i = 1, … n $$\ndonde,\n$\\beta_i$ representan los coeficientes que describen la relación o la influencia que tiene la variable $x_i$ sobre la variable dependiente.\n$\\beta_0$ representa el intercepto. Este valor describe la relación entre la variable dependiente y las variables independientes $x_i$, cuando $x_i$ = 0.\n$x_i$ son las variables independientes utilizadas en el modelo.\n$\\epsilon_i$ representa el error aleatorio que se introduce en el modelo por cada variable independiente $x_i$. Estos errores son independientes y siguen una distribución normal. $\\epsilon_i \\sim \\mathcal{N}(0, \\sigma^2) $\nMínimos cuadrados ordinarios Existen distintos métodos para determinar los coeficientes $\\beta$, uno de ellos es mínimos cuadrados ordinarios. statsmodels es una librería de Python que contiene una colección grande de modelos estadísticos. Para ajustar un modelo lineal usando mínimos cuadrados ordinarios, usaremos la función ols (ordinary least squares, en inglés).\nfrom statsmodels.formula.api import ols Ahora usaremos los datos edadpesograsas.txt que nos servirá para entender el uso de ols. Este archivo contiene información de edad, peso y cantidad de grasas en 25 pacientes.\nLo primero que haremos es importar los datos. Como estos datos provienen de un archivo de texto (*.txt), usaremos ahora el método read_table() de pandas. El separador usado en este archivo es un tabulador. Daremos esta información al método para que el archivo se importe correctamente:\n# Importar datos edad_peso = pd.read_table(\"edadpesograsas.txt\", sep=\"\\t\") La sintaxis de ols es la siguiente:\nmodel = ols('variable_dependiente ~ variable1 + variable2 + ... +', df).fit() Intentemos modelar la cantidad de grasas respecto a la edad:\nmodel = ols('grasas ~ edad', edad_peso).fit() Para revisar la información del modelo de regresion, usamos el método summary()\n# Ver resultados model.summary() Ahora agreguemos la variable peso al modelo de regresión:\nmodel = ols('grasas ~ edad + peso', edad_peso).fit() ¿Mejoró el modelo?\n Regresión paso a paso Lo que acabamos de hacer se llama regresión paso a paso (stepwise regression, en inglés). Esta metodología es iterativa, pues implica seleccionar variables de forma automática y ver como mejora (o empeora) el modelo. Existen dos tipos de selección:\n  Selección hacia adelante (Forward selection, en inglés): En este tipo de selección, el modelo se inicia sin ninguna variable. Después se agrega una variable a la vez y se prueba si mejoró la calidad del modelo con la inclusión de dicha variable.\n  Selección hacia atrás (Backward selection, en inglés) En este tipo de selección, se inicia con un modelo que incluye todas las variables. Después se elimina una variable a la vez y se prueba si mejoró la calidad del modelo con la eliminación de dicha variable.\n  Este método es adecuado cuando se tiene una cantidad significativa de variables que explican el fenómeno a modelar y se desea empezar a eliminar variables irrelevantes. Sin embargo, siempre se preferirá analizar y entender los datos antes de crear modelos.\n  Con esto concluimos este tema.\nReferencias y material adicional   Precipitacion. CONAGUA. Datos abiertos de México. Disponible en: https://datos.gob.mx/busca/dataset/precipitacion\n  Datos para la docencia. José Ramón Berrendero Díaz. Disponible en: https://verso.mat.uam.es/~joser.berrendero/datos.html\n  SciPy documentation. The SciPy community. Disponible en: https://docs.scipy.org/doc/scipy/\n  T-test con Python. Ciencia de datos. Disponible en: https://www.cienciadedatos.net/documentos/pystats10-t-test-python.html\n  Statistics in Python. Scipy lecture notes. Disponible en: https://scipy-lectures.org/packages/statistics/index.html\n  Statistical hypothesis tests in Python cheat sheet. Machine learning mastery. Disponible en: https://machinelearningmastery.com/statistical-hypothesis-tests-in-python-cheat-sheet/\n  ","description":"Pruebas de hipótesis y regresión","tags":["pandas","scipy","statsmodels","estadistica"],"title":"6. Análisis estadístico","uri":"/datlab/dap101/6-stats/"},{"content":"Introducción Ahora que hemos aprendido sobre como usar las librerías de manipulación de datos, visualizaciónes y análisis estadístico, haremos un pequeño ejercicio.\nDatos\nUsaremos el siguiente archivo para recapitular todo lo aprendido:\n Archivos endutih_vivienda_anual_2019_enc.csv (992 KB)   Estos son datos recopilados por INEGI en su encuesta ENDUTIH de 2019. La descripción de las columnas es la siguiente:\n   Variable Tipo variable Descripción pregunta     energia_electrica Binaria La vivienda dispone de energía eléctrica   refrigerador Binaria La vivienda dispone de refrigerador   lavadora Binaria La vivienda dispone de lavadora   auto_propio Binaria Las personas viviendo en esta vivienda disponen de automóvil o camioneta   personas_vivienda Numérica Número de personas viviendo normalmente en la vivienda   mismo_gasto Binaria El gasto para comer de todas las personas viviendo en la vivienda es el mismo   TLOC Numérica (ordinal) Tamaño de la Localidad (1: 100 000 y más habitantes, 2: 15 000 a 99 999 habitantes, 3: 2 500 a 14 999 habitantes, 4: menor a 2500 habitantes)   ESTRATO Numérica (ordinal) Estrato socioeconómico. (1: Bajo, 2: Medio bajo, 3: Medio alto, 4: Alto)   material_1 Binaria El material predominante del piso de esta vivienda es tierra   material_2 Binaria El material predominante del piso de esta vivienda es cemento   material_3 Binaria El material predominante del piso de esta vivienda es madera, mosaico u otro   fuente_agua_1 Binaria La fuente de agua es agua entubada dentro de la vivienda   fuente_agua_2 Binaria La fuente de agua es agua entubada fuera de la vivienda, pero dentro del terreno   fuente_agua_3 Binaria La fuente de agua es agua entubada de llave pública (o hidrante)   fuente_agua_4 Binaria La fuente de agua es agua entubada que acarrean de otra vivienda   fuente_agua_5 Binaria La fuente de agua es agua de pipa   fuente_agua_6 Binaria La fuente de agua de la vivienda es agua de un pozo, río, arroyo, lago u otro   conexion_drenaje_1 Binaria La vivienda tiene drenaje o desagüe conectado a la red pública   conexion_drenaje_2 Binaria La vivienda tiene drenaje o desagüe conectado a una fosa séptica   conexion_drenaje_3 Binaria La vivienda tiene drenaje o desagüe conectado a una tubería que va a dar a una barranca o grieta   conexion_drenaje_4 Binaria La vivienda tiene drenaje o desagüe conectado a una tubería que va a dar a un río, lago o mar   conexion_drenaje_5 Binaria La vivienda no tiene drenaje o desagüe   tipo_poblacion_R Binaria La vivienda se encuentra en una población rural   tipo_poblacion_U Binaria La vivienda se encuentra en una población urbana    Inspección de datos Empezamos importando las librerías que usaremos y los datos.\nimport pandas as pd import seaborn as sns import matplotlib.pyplot as plt from statsmodels.formula.api import ols Ahora importemos los datos y revisemos el tamaño del DataFrame.\nencuesta_vivienda = pd.read_csv(\"endutih_vivienda_anual_2019_enc.csv\") encuesta_vivienda.shape Esto nos devuelve la tupla (21163, 24). Es un set de datos grande. Pero no es problema para Python.\nAnálisis exploratorio Ahora veamos las medidas de estadistíca descriptiva.\nencuesta_vivienda.describe() Tal vez estos resultados no nos ayuden mucho puesto que son datos con mayormente variables binarias (0 y 1).\nMatriz de correlaciones La matriz de correlaciones se puede obtener con pandas usando el método corr(). Las correlaciones pueden calcularse usando distintos métodos como Pearson, Spearman y Kendall usando el argumento method.\nPara este caso, utilizaremos Spearman como método puesto que la mayor parte de las variables son binarias y sólo dos son de tipo ordinal.\ncorr_matrix = encuesta_vivienda.corr(method = \"spearman\") Esto nos devuelve otro DataFrame con la matriz de correlaciones. Este nuevo DataFrame tiene un tamaño de 24 x 24.\nVisualizaciones Podemos ver la matriz de correlaciones con una visualización llamada heatmap.\n# Heatmap plt.figure(figsize = (18,12)) # Hacer más grande la figura sns.heatmap(corr_matrix, annot = True, cmap = \"Blues\") Hemos pasado un par de argumentos nuevos. annot nos reportará el valor del factor de correlación en la visualización. cmap es el mapa de colores que que seaborn usará. Para mejorar la vista, hemos usado la paleta Blues. Si el factor de correlación se acerca más al valor 1, el cuadro tendrá un color azul más fuerte. Si te interesa ver más opciones puedes ver la documentación de colormaps de matplotlib.\nAdicionalmente, por ser una visualización de 24x24, el tamaño de la figura debe ser más grande.\nEnfoquémonos en las variables ESTRATO y TLOC, que son numéricas.\nsns.histplot(encuesta_vivienda[\"ESTRATO\"]) Podemos ver que es una variable discreta, puesto que tiene valores enteros que van del 1 al 5. Podemos ver que hay menos personas con un estrato 4 (estrato alto), mientras que la mayor parte de las respuestas tienen un estrato 2 (estrato medio bajo).\nsns.histplot(encuesta_vivienda[\"TLOC\"]) De igual manera, TLOC es una variable discreta. Los grupos de encuestados más representativos en la muestra, son de localidades con 100,000 y más habitantes, y de localidades con menos de 2500 habitantes.\nTracemos una recta entre ambas variables para encontrar más relaciones.\nsns.lineplot(data = encuesta_vivienda, x = \"TLOC\", y = \"ESTRATO\") Podemos ver que conforme aumenta TLOC, ESTRATO decrece. Parece tener sentido.\nModelo de regresión lineal Nos interesa entender cuáles son las variables que definen el estrato socioeconómico de una familia.\nPodríamos empezar haciendo un modelo usando regresión paso a paso. O también, usando las variables que tienen más correlación con el estrato socioeconómico.\n# Ajuste de datos  formula = \"ESTRATO ~ material_3 + fuente_agua_1 + TLOC + tipo_poblacion_U + \\ conexion_drenaje_1 + refrigerador + lavadora + auto_propio\" modelo_ols = ols(formula, encuesta_vivienda).fit()   Trivia ¿Por qué no agregar tipo_poblacion_R también?\n  Con este modelo, estamos teorizando que el estrato depende de dichas variables. Inspeccionemos el modelo.\n# Revisar modelo modelo_ols.summary() Obtuvimos un modelo con un $R^2$ ajustado de 0.527. Adicionalmente, statsmodels nos devuelve los parámetros $\\beta_i$ con su respectivo intervalo de confianza, y una prueba t sobre cada parámetro.\n Prueba t en coeficientes de regresión La prueba t contrasta si el parámetro $\\beta_i$ calculado es relevante para ajustar los datos o no. Las hipótesis están definidas como:\n$$H_0: \\beta_i = 0 $$ $$H_1: \\beta_i \\neq 0 $$\nAsimismo, nos regresa los valores-p de dicha prueba. (¿Cuándo rechazábamos la hipótesis nula?)\n  Evaluación del modelo Veamos qué tal predice nuestro modelo el estrato socioeconómico.\n# Guardamos la predicción del modelo en una Serie Y_pred = pd.Series(modelo_ols.predict()) Juntemos las series usando el método concat().\ncomparison = pd.concat([encuesta_vivienda[\"ESTRATO\"], Y_pred], keys = [\"ESTRATO\", \"ESTRATO_p\"], axis = 1) Ahora calculemos columnas de error. El error se define como la diferencia del valor observado $y_i$ menos valor predecido $\\hat{y}_i$.\n Error: $y_i - \\hat{y}_i$ Error cuadrado: $(y_i - \\hat{y}_i)^2$ Error absoluto: $| y_i - \\hat{y}_i |$  # Crear columnas con errores def calculate_errors(df): df[\"error\"] = df.iloc[0:,0] - df.iloc[0:,1] df[\"sq_error\"] = (df[\"error\"])**2 df[\"abs_error\"] = abs(df[\"error\"]) return df Ahora, usemos la función para calcular los errores como columnas adicionales.\ncomparison = calculate_errors(comparison) Si bien esto nos calcula los errores, aún no nos dice qué tan bien predice el modelo el estrato socioeconómico.\nDefinimos las siguientes métricas:\n$$\\text{MAE} = \\frac{\\sum_{i=1}^{N}| y_i - \\hat{y}_i |}{N} \\ \\ \\ \\ \\ \\ \\ \\text{(Error absoluto medio)}$$\n$$\\text{RMSE} = \\sqrt{\\frac{\\sum_{i=1}^{N}( y_i - \\hat{y}_i )^2}{N}} \\ \\ \\ \\ \\ \\ \\ \\text{(Raíz del error cuadrático medio)}$$\nEstas métricas son utilizadas para determinar la calidad del modelo de regresión implementado.\n# Una pequeña función para calcular las métricas del modelo de regresión def model_metrics(df): MAE = df[\"abs_error\"].sum()/df[\"abs_error\"].count() RMSE = (df[\"sq_error\"].sum()/df[\"sq_error\"].count())**(1/2) print(\"Métricas del modelo\") print(\"MAE: {}\\tRMSE: {}\".format(MAE, RMSE)) return None model_metrics(comparison) Esto nos devuelve la siguiente información:\nModel metrics MAE: 0.5490078148166975 RMSE: 0.7043990103948065   Trivia ¿Qué nos dice cada métrica?\n  Conclusión # Aqui van tus comentarios ;) Referencias y material adicional   Encuesta Nacional sobre Disponibilidad y Uso de Tecnologías de la Información en los Hogares (ENDUTIH) 2019. INEGI. Disponible en: https://www.inegi.org.mx/programas/dutih/2019/\n  Modelos Lineales. Jesús Montanero Fernández. Disponible en: http://matematicas.unex.es/~jmf/Archivos/MODELOS_LINEALES.pdf\n  Linear Regression - statsmodels. Josef Perktold, Skipper Seabold y Jonathan Taylor. Disponible en: https://www.statsmodels.org/stable/regression.html\n  ","description":"Ejercicio final para recapitular lo aprendido en el curso","tags":null,"title":"7. Recapitulación","uri":"/datlab/dap101/7-proyecto/"},{"content":"Especificaciones Para seguir los materiales publicados en este sitio se espera que la computadora tenga las siguientes especificaciones técnicas:\n Sistema operativo:  Windows 8 o superior MacOS 10.13 64-bit o superior Linux: Mientras sea una distribución soportada como Ubuntu, RedHat, Fedora, Debian…   Memoria RAM: Al menos 4 GB, pero mucho mejor más de 8 GB. Espacio en disco: Al menos 10 GB disponibles en disco.  Programas Para poder programar, necesitamos varias piezas que harán la vida más simple cuando empecemos a escribir código y ejecutar nuestros programas.\n Una distribución de Python. En otras palabras, el lenguaje de programación. Un editor de código o un entorno integrado de desarrollo para poder escribir código. Un editor de texto más adecuado que el que viene con la instalación típica de Windows o Mac.   Un sistema de control de versiones. Esto es para quienes colaboren en proyectos con una carga mayor de producción de código, con más colaboradores o no, y que se requiera un seguimiento más detallado del trabajo realizado. En caso de emergencias, control de versiones puede ayudarnos a recuperar archivos o volver a un punto donde el proyecto funcionaba de cierta manera :D  Para cada una de estas piezas, recomiendo los siguientes programas (Todos son gratuitos):\n Anaconda. Esta distribución contiene los paquetes más utilizados como matplotlib, NumPy, pandas, scipy, seaborn, entre otros; y los socorridísimos Jupyter notebooks. Visual Studio Code (También conocido como VSCode) como editor de código. Es liviano, multiplataforma y con bastantes extensiones que mejoran la experiencia de programación. Soporta varios lenguajes de programación. Para Python, he encontrado que VSCode es cómodo. Notepad++ es hasta ahora, el mejor editor de texto que he encontrado para Windows. Nos será muy útil para muchas más cosas, no sólo para programar. Desafortunadamente Notepad++ no tiene soporte para otros sistemas operativos. Como alternativas, está Notepadqq para Linux. En Mac están Atom y Sublime Text, aunque este último nunca lo he utilizado. Git. Control de versiones libre más utilizado   Nota También existen los entornos integrados de desarrollo (Integrated Development Environment, IDE, en inglés) que son programas con muchas más funcionalidades que un editor de código. Por ejemplo, Visual Studio es muy conocido, aunque por lo mismo, puede ser pesado y consumir bastantes recursos. Para estos cursos, nos limitaremos a usar VSCode por su soporte multiplataforma y entorno modular.\n  ","description":"","tags":null,"title":"Prerrequisitos","uri":"/datlab/basics/requirements/"},{"content":"Aquí se detallan los pasos para la instalación de los programas sugeridos en la sección de Prerrequisitos. Las recomendaciones mostradas aquí son válidas para computadoras con sistema operativo Windows. Afortunadamente macOS y Linux son mucho más simples para instalar y configurar, aunque puedes usar el orden sugerido.\nEn matemáticas, el orden de los factores no altera la suma ni el producto. Desafortunadamente, aquí sí afecta el orden de instalación :( Para evitar modificar variables de entorno posteriormente (y a mano), recomiendo el siguiente orden:\n Notepad++ Sólo Windows Anaconda VSCode Git (Si se necesita usar control de versiones.)  Notepad++ Notepad++ es muy rápido de instalar y no causa problemas. Con seguir los pasos de la instalación es suficiente. \nAnaconda Sólo Windows: En algún punto de la instalación de Anaconda, veremos las opciones avanzadas:\nEncarecidamente recomiendo activar la casilla “Add Anaconda3 to my PATH environment variable”. Aunque el instalador dice que no es recomendable, es la mejor opción para que VSCode encuentre a Anaconda.\nVSCode Sólo Windows: Esta instalación es muy amigable. Sólo recomiendo revisar que la casilla “Add to PATH” esté activada.\nGit Cuando instalemos Git, el instalador pedirá seleccionar el editor de texto predeterminado. En la lista desplegable, elegir Notepad++ (Aquí es una de las razones por las que seguimos este orden de instalación). No pasa nada si no se cambia, pero en caso de necesitar hacer troubleshooting de un cambio hecho directamente en la consola de Git, Vim puede ser complicado al inicio.\n","description":"","tags":null,"title":"Instalación","uri":"/datlab/basics/installation/"},{"content":"Una vez que todo está instalado, recomiendo reiniciar el sistema antes de empezar. En sistemas Windows, se forza a que el sistema reconozca el contenido de las variables de entorno.\nVSCode va a ser nuestro editor de código. Como se mencionó anteriormente, es liviano y diseñado de tal manera que podemos personalizarlo con lo que necesitemos, haciéndolo muy cómodo incluso con computadoras con pocos recursos.\nExtensiones VSCode Para instalar extensiones, podemos hacerlo de dos formas:\n Visitando el sitio Marketplace de VSCode y buscando la extensión que deseamos instalar.   Directamente desde VSCode, visitando la tab de Extensions.   Soporte a Python Esto se logra instalando la extensión de Python para VSCode. La instalación es rápida. Esta extensión ya tiene integrados PyLance (nos dará tips para autocompletar expresiones mientras programemos) y soporte a Jupyter :)\nUna vez que esté instalada esta extensión, tenemos que asegurarnos que VSCode reconozca que Anaconda es nuestro intérprete de Python.\nPara esto, accedemos a la paleta de comando de VSCode usando los siguientes atajos:\n Windows / Linux: Ctrl+Shift+P o F1 MacOS: ⇧⌘P o F1  Buscamos interpreter y seleccionamos la opción Python: Select Interpreter\nAllí buscamos la opción ‘base’: conda. En una instalación nueva, sólo aparecerá esta opción. En mi caso tengo un ambiente adicional que cree para un proyecto de datos geoespaciales.\nSoporte a idioma español (opcional) VSCode se instala sólo con idioma inglés. Si deseas tener el software en español, puedes instalar la extensión Spanish Language Pack para que la interfaz esté en español. Es importante recalcar que la mayoría de la documentación y de los foros con tips estarán en inglés.\nTemas (opcional) Los temas son un conjunto de colores que se aplican en la interfaz, tanto en el fondo como en el texto en el editor. VSCode tiene bastantes temas para personalizar la experiencia. Es importante que esto se haga de acuerdo al gusto personal.\nMis temas favoritos son:\n Visual Studio Blue Este es un tema claro y el que uso durante el día o en habitaciones con muy buena iluminación. Blue fue el tema que usaba cuando aprendí a programar en VS 2017, entonces estoy sesgada  Dracula Este es un kit de temas oscuros que uso cuando estoy programando por las noches o en habitaciones con poca iluminación.  Para ver más temas, puedes consultar VSCode Themes o directamente desde las extensiones en VSCode.\nGit y GitHub (opcional) Es una buena práctica llevar una gestión de cambios en todos los archivos que generemos con código. A veces pueden pasar desastres en nuestras computadoras y podemos perder todo. GitHub es un sitio donde se pueden gestionar todos los repositorios Git en la nube, gestionar colaboraciones entre equipos, entre otras cosas.\nMuchos desarrolladores usan GitHub como un portafolio para mostrar a posibles empleadores los proyectos en los que han trabajado.\nPara configurar GitHub y Git, seguiremos estos pasos:\n Registro en GitHub. Es muy simple. Configuración de Git en nuestro sistema con el usuario y el correo utilizado al registrarnos en GitHub.  Abrimos Git CMD en Windows o Terminal en MacOS / Linux. Los siguientes comandos modifican la identidad.\n$ git config --global user.name \"Mi Usuario GitHub\" $ git config --global user.email correo@ejemplo.com Revisamos que los cambios se hayan hecho con el siguiente comando:\n$ git config --list ","description":"","tags":null,"title":"Configuración","uri":"/datlab/basics/configuration/"},{"content":"Changelog 0.1.0 (2022-05-02) Primer curso completo  Contenido del curso Análisis de datos en Python terminado. Finalizada la revisión ortográfica y gramatical del curso.  Mantenimiento  Inclusión de licencia CC en el footer.  0.0.8 (2022-05-01) Actualización a Análisis de datos en Python  Temario completo Revisión ortográfica y gramatical de todo el curso.  0.0.7 (2022-04-30) Actualización a Análisis de datos en Python  Actualización al tema Recapitulación Inclusión de párrafo de introducción en el tema Bucles Inclusión de tópicos adicionales en Manejo de datos Inicio de revisión ortográfica y gramatical de todo el curso. Revisión menor al tópico de Instalación.  0.0.7 (2022-04-29) Actualización a Análisis de datos en Python  Inclusión de prueba de Levene y regresión lineal en el tema Análisis estadístico  0.0.6 (2022-04-28) Actualización a Análisis de datos en Python  Creación del ejercicios de prueba de hipótesis del tema Análisis estadístico Inicio de revisión ortográfica para Bucles, Manejo de datos y Visualizaciones Actualización de referencias en los temas: Introducción a Python, Primer programa, Bucles, Manejo de datos, Visualizaciones y Análisis estadístico Ligera restructuración en tema Primer programa Inclusión de una breve introducción en temas: Introducción a Python, Manejo de datos, Visualizaciones y Análisis estadístico Inclusión de tags con palabras clave para cada tema  0.0.5 (2022-04-27) Actualización a Análisis de datos en Python  Creación de ejercicios del tema Visualizaciones  Soporte a MathJax  Ahora el sitio soporta MathJax para escribir ecuaciones :)  0.0.4 (2022-04-26) Actualización a Análisis de datos en Python  Creación de ejercicios y tareas de los temas Bucles y Manejo de datos Placeholders para Visualizaciones, Analisis estadistico y tentativamente, Proyecto final  Mantenimiento  Limpieza de archivos ejemplo  0.0.3 (2022-04-21) Actualización a Análisis de datos en Python  Creación de ejercicios y tareas del tema Primer programa  0.0.2 (2022-04-20) Creación material del taller Análisis de datos en Python  Creación de la sección Análisis de datos en Python Creación de ejercicios y tareas del tema Introducción a Python  Mantenimiento  Limpieza de archivos ejemplo sin usar  0.0.1 (2022-04-19) Primer borrador del sitio  Creación de la sección de Inicio  Mantenimiento  Migración del theme Learn a Relearn para evitar el bug que ocasionaba el landing page URL cuando existe un idioma distinto al inglés  ","description":"","tags":null,"title":"Historia","uri":"/datlab/basics/history/"},{"content":"Dat Lab Dat Lab es un espacio que nace por la idea de aportar herramientas necesarias a personas con poca o nulo acercamiento a programación, pero que tienen interés en mejorar su productividad (sea en investigación, sector público o privado) y así dar una recarga a su portafolio de habilidades técnicas.\nTengo muchas más ideas en mente para futuros cursos, por ejemplo:\n Bases de Ciencia de Datos Machine Learning para todos Estadística aplicada Optimización y Heurísticas Composición de documentos y presentaciones con LaTeX  Si alguno de estos temas te interesa, ¡contáctame! Seguro que algo podremos convenir.\n¿Quién escribe esto? Me llamo Mariel. Soy una mexicana que código escribía, ciruela, chabacano… . Tengo más de 7 años de experiencia en la industria de software, trabajando en varios frentes como implementación, soporte técnico, investigación y desarrollo de software.\nDespués de unos de años trabajando en software, decidí tomar un tiempo para contribuir un poco a la sociedad y hacer más accesibles las técnicas y las nuevas tecnologías disponibles para análisis. Me gusta mucho crear soluciones aplicando ciencia y tecnología, pero más me gusta compartir conocimiento.\nPara más información sobre mi experiencia y/o lo que estoy haciendo actualmente, puedes visitar mi sitio de GitHub o mi perfil de LinkedIn\n","description":"","tags":null,"title":"About","uri":"/datlab/more/about/"},{"content":"","description":"","tags":null,"title":"Categories","uri":"/datlab/categories/"},{"content":"Colaboradores Gracias a todos los que han contribuido en el proyecto Relearn.\n¡Gracias a ustedes!\n","description":"","tags":null,"title":"Créditos","uri":"/datlab/more/credits/"},{"content":"Dat Lab Aquí encontrarás los materiales preparados para acompañar los talleres de Python y de Análisis de datos.\n¿Podrías llenar la siguiente encuesta al empezar el curso? Link a la encuesta\n","description":"","tags":null,"title":"Dat Lab","uri":"/datlab/"},{"content":"To be added\n","description":"","tags":null,"title":"Escaparate","uri":"/datlab/more/showcase/"},{"content":"","description":"","tags":null,"title":"estadistica","uri":"/datlab/tags/estadistica/"},{"content":"","description":"","tags":null,"title":"matplotlib","uri":"/datlab/tags/matplotlib/"},{"content":"","description":"","tags":null,"title":"pandas","uri":"/datlab/tags/pandas/"},{"content":"","description":"","tags":null,"title":"python","uri":"/datlab/tags/python/"},{"content":"","description":"","tags":null,"title":"scipy","uri":"/datlab/tags/scipy/"},{"content":"","description":"","tags":null,"title":"seaborn","uri":"/datlab/tags/seaborn/"},{"content":"","description":"","tags":null,"title":"statsmodels","uri":"/datlab/tags/statsmodels/"},{"content":"","description":"","tags":null,"title":"Tags","uri":"/datlab/tags/"},{"content":"","description":"","tags":null,"title":"visualizaciones","uri":"/datlab/tags/visualizaciones/"}]